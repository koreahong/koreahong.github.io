---
layout: post
title:  "SQLD 요약"
subtitle:   "sql명령분 부터 최적화 까지"
categories: book
tags: study
comments: true
---

> sql 요청->파싱->옵티마이저->실행계획->sql실행

# 1. 데이터 모델링
## 1-1. 데이터 모델링 이해
	-추상화 : 현실세계 -> 데이터베이스
	-설계단계 : 개념->논리->물리
	-개념 : ERD 등, 엔티티, 관계 설정
	-논리 : 식별자 정의, 정규화 진행
	-물리 : DB 구축

## 1-2. 3층 스키마
	-DB 독립성 확보를 위함
	-외부스키마 : 사용자 관점
	-개념스키마 : 설계자 관점
	-내부스키마 : 물리적저장구조

	-각 스키마가 변경되어도 다른 스키마에 영향을 끼치지 않음

## 1-3. 앤티티
	-앤티티는 식별자, 인스턴스집합, 속성, 관계, 업무의 특성을 가지고 있음

## 1-4. 속정(정보)
	-단일속성 
	-복합속성 : 여러 개의 의미가 있는 것 ex) 주소(시군구)
	-다중값속성 : 여러개 값을 갖을 수 있는 것 ex) 상품리스트

## 1-5. 관계 - 앤티티간의 참여하는 수
	-1대1, 1대다, 다대다

##1-6. 식별자(기본키)
	-기본키 : 후보키 중 대표할 수 있는 것
	-후보키 : 유일성 o, 최소성 o
	-슈퍼키 : 유일성 O, 최소성 x
	-대체키 : 후보키 중 선정되지 않은 나머지
	-외래키 : 허용된 데이터 값만 저장하기 위함, 다른 테이블의 기본키 필드를 가리키는 것

# 2. 데이터 모델과 성능

## 2-1. 정규화
	- 데이터 중복제거, 모델의 독립성 확보
	- 5정규화까지 있으나 실질적으로 3정규화까지 진행

## 2-2. 정규화과정
	- 1정규화 : 기본키를 설정, 함수적 종속성 확인
	- 2정규화 : 부분 함수 종속성 제거(테이블 분해), 일부의 데이터가 기본키의 일부분에 종속됨
	- 3정규화 : 이행 함수 종속성제거(데이블 분해), 기본키를 제외한 칼럼들 중 서로 종속관계이 있는 것을 분해
	- BCNF : 기본키가 호부키에 종속되는 관계를 분해

## 2-3. 정규화의 문제점
	- 모델의 유연성 높아짐, 조인 유발 많아짐 -> CPU, 메모리 사용 높아짐
	- 이러한 문제점을 반정규화로 해결

## 2-4. 반정규화
	- 데이터 중복 허용, 조인 감소, 조회속도 상승, 유연성 낮아짐

# 3. SQL 기본

## 3-1. 관계형 데이터베이스
	- 릴레이션의 조인연산 가능, 합집함, 교집합등 개념 사용 가능
	- DBMS DB를 관리하는 소프트웨어

## 3-2. 테이블 구조
	- 컬럼, 기본키, 왜래키, 행

## 3-3. SQL 종류
	- DDL : DB 구조 정의
	- DML : 입력, 수정, 조회 등
	- DCL : 권한 부여, 회수 등
	- TCL : 트랙섹션 제어, 트랙섹션 : DB작업 단위

## 3-4. DDL
	- CREATE : 테이블 생성
	- ALTER : 테이블 변경
	- DROP : 테이블 삭제
	- CASCADE : 참조관계가 있을 경우 참조되는 테이터를 자동으로 반영

	- 예시 : CREATE TABLE 테이블 이름 ( 컬럼이름 데이터 타입, constraint 기본키 이름 primary key 컬럼이름)
	- 예시 : ALTER TABLE 테이블 명 RENAME TO 테이블 명
	- 예시 : DROP TABLE 테이블 명

## 3-5. DML
	- INSERT, SELECT, DELETE
	- SELECT문
		- DISTINCT : 중복제거
		- ALIAS : 별칭
	- WHERE
		- 비교연산자 : =, <, <=, >, >=
		- 부정비교 : !=, ^=, <>, NOT 컬럼명
		- 논리연산자 : AND, OR, NOT
		- SQL 연산자 : LIKE '%비교문자열%', BETWEEN A AND B, IN, IS NULL
		- 부정 SQL : NOT BETWEEN, NOT IN, IS NOT NULL

	- GROUP BY, HAVING, ORDER BY
		- GROUP BY절 : COUNT, SUM, COUNT(컬럼명)

## 3-6. 내장형함수
	- 문자형 함수 책 참고
		- ASCII(문자), CHAR(ASCII 코드값), SUBSTR(문자열,m,n), CONCAT(문자열1, 문자열2), LOWER(문자열), UPPER(문자열) 등
	- 날짜형 함수 
		- SYSDATE, EXTRACT('YEAR' | 'MONTH' | 'DAY' from 테이블 명)
	- 숫자형 함수
		- ABS(숫자), SIGN(숫자), MOD(숫자1, 숫자2), CEIL/CEILING(숫자), FLOOR(숫자)

## 3-7. DECODE/CASE
	- DECODE = IF문
		- DECODE(테이블 명, 조건), 참일때, 거짓일때)
	- CASE
		- CASE WHEN 조건 1 THEN 결과 ...... ELSE 결과 END

## 3-8. ROWNUM/ROWID
	- WHERE ROWNUM <= 숫자
		- MYSQL은 LIMIT 사용
	- ROWID는 DB 내에서 데이터를 구별할 수 없는 유일한 값

## 3-9. WITH
	- 서브쿼리를 사용하여 임시 테이블처럼 사용할 수 있는 구문

# 4. SQL 활용

## 4-1. 등가(EQUI)조인
	- 두개의 테이블간에 일치하는 것 조인
	- INNER JOIN
	- OUTER JOIN : FULL, LEFT, RIGHT
	- CROSS JOIN : 조인 조건구 x, 카테시안 곱 발생
	- UNION : 2개의 테이블을 하나로 만듬, 중복된 데이터 제거, SORT과정 발생
	- UNION ALL : 중복O, 정렬 x
	- MINUS

## 4-2. subquery(인라인 뷰 활용)
	- 단일 행 비교연산자 : 비교연산자
	- 다중 행 비교연산자 :  IN, AND, ANY, EXISTS

## 4-3. 스칼라
	- 반드시 한 행, 한 컬럼만 반환

## 4-4. 그룹함수
	- ROLLUP : subtotal을 만들어 줌
		- GROUP BY ROLLUP(컬럼명)
	- GROUPING : 소계값인지 아닌지 확인 해주는 함수, 0 or 1 반환
	- GROUP Sets : 칼럼에 상관없이 개별처리
	- CUBE : 결합 가능한 모든 집계

# 5. SQL 최적화의 원리

## 최적화
	- 옵티마이저
		- SQL을 어떻게 실행할지 계획
		- 예상되는 비용 산정, 비용 : SQL을 실행하는데 소요되는 자원의 사용
	- 과정 : SQL -> 파싱 -> 옵티마이저 -> 실행계획 -> SQL 실행
	- 힌트 : 옵티마이저에게 실행되는 방법을 알려주는 것
	- 인덱스 : 데이터를 빠르게 검색할 수 있는 방법을 제시
	- 옵티마이저 조인 
		- NESTED JOIN : 순차적으로 테이블 데이터 찾기, random access  큼
		- SORT JOIN : 정렬 후 병합
		- HASH JOIN : 주소 계산 후 조인, CPU 연산 많음




