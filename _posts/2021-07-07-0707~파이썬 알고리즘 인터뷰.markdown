---
layout: post
title: '0707~, 파이썬 알고리즘 인터뷰 요약'
#subtitle: '구조화된 코드는 어떤 거인가'
categories: algorithm
#tags : software  
comments: False
---

> 파이썬 알고리즘 인터뷰 요약

[자료구조 구현 코드](https://colab.research.google.com/drive/11WDB2N_NDSigqaIYCZb87yeoDSzkp95F?usp=sharing)
  
# 요약의 목적
- 도움이 될만한 독자 : 코딩-중하 이상
- 해당 요약의 중점은 다음과 같다
    - 핵심개념 정리
    - 빠르게 훑고 지나가기
    - 파이써닉한 코딩
- 알고리즘 문제
    - 리트코드 / 번호찾기

# 1부 코딩 인터뷰  
## 1장. 코딩인터뷰  

- WHAT?
    - 코딩테스트 : TOOL에서 온라인/오프라인 테스트를 치는 것. 구현, 최적화 초점
    - 코딩인터뷰 : 면접관들 앞에서 문제를 푸는 방식. 문제를 푸는거에 초점
    
- WHY?
    - 알고리즘 : 체계적으로 문제를 풀어나갈 수 있는 역량
    - 구글 등에서 코딩테스트의 효용성을 입증함
 
- HOW?
    - 해커랭크, 프로그래머스와 같은 tool 활용

## 2장. 프로그래밍 언어 선택

- WHAT?
    - python 3.7

- WHY?
    - 면접관이 쉽게 이해할 수 있음
    - 대부분의 코딩 플랫폼에서 지원
    - 유연한 언어이다.
    - 언어레벨에서 풍부한 지원
 
- HOW?
    - 다양한 라이브러리 활용가능
    
# 2부 파이썬
## 3장. 파이썬이란
- WHAT?
    - 프로그래밍 언어
- WHY?
    - 읽기 쉬운 언어
    - 사용자가 원하는 모듈 패키지를 만들 수 있어야 하며, 다른 프로그램에서 사용할 수 있어야 함
- HOW?
    - pip로 라이브러리 다운
    
## 3장. 파이썬 문법
### 인덴트
- WHAT?
    - 공백
- WHY?
    - 가독성 높이기 / 가이드라인
- HOW?
    - 공백 4칸 들여쓰기
    - 파이참 리포맷 기능 활용

### 네이밍 컨벤션
- WHAT?
    - 변수명
- WHY?
    - 가독성
    - 파이썬 pep8 가이드 양식
    - 파이썬 철학
- HOW?
    - 스네이크 케이스 / '_' 추가방식
    
### 타입힌트
- WHAT?
    - 파라미터 타입 명시
- WHY?
    - 프로젝트 규모가 크면 가독성이 떨어지고 버그 유발의 주범이 됨
- HOW?
    - 파라미터와 리턴값을 명시
    
### 리스트 컴프리핸션
- WHAT?
    - 기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문
- WHY?
    - map, filter를 사용하는 것보다 가독성이 훨씬 좋음
- HOW?
    - [기존 리스트 for문 if문 등]
    
### 제너레이터
- WHAT?
    - 루프의 반복동작을 제어할 수 있는 루틴 형태
- WHY?
    - 제너레이터만 생성해두고 필요할 때 언제든 숫자를 만들어낼 수 있다.
    - 저장공간을 아낄 수 있음
- HOW? 
    - yield와 next 구성
    - 생성 조건만 보관
    
### print
- WHAT?
    - 출력 결과를 보여주는 것
- WHY?
    - 중간중간 디버깅하기 위함(비추)
- HOW?
    - f-string ex : ```python print(f'{idx+1}: {fruit}')```
    
### pass
- WHAT?
    - Null연산으로 아무것도 하지 않는 기능
- WHY?
    - 목업 인터페이스부터 구현한 다음에 추후 구현을 진행하기 위해서
- HOW?
    - ```python def method_a() pass```
    
### 코딩스타일
- WHAT?
    - 코딩하는 스타일
- WHY?
    - 개발은 같이 하는 부분이기 때문에 많은 사람들이 선호하는 방식을 선택해야 함
- HOW?
    - PEP8과 같은 가이드라인 참고
    
### 변수명과 주석
- WHAT?
    - 변수명과 주석
- WHY?
    - 가독성을 높이기 위해
- HOW?
    - 간단한 주석 부여
    - 영어로 작성

## 4장. 빅오, 자료형
### 빅오
- WHAT?
    - 입력값에 대한 알고리즘의 실행 상한 시간
- WHY?
    - 시간복잡도와 공간복잡도 증가 추이 확인
    - 알고리즘의 효율성을 분석하기 위해
- HOW?
    - 입력값이 무한대로 향할때 함수의 상한 측정
    - 최고차항만 표기, ex) an^2 + bn => O(n^2)
- plus
    - 빅오표기법은 적당히 정확하게 표현하는 방법
    - 최악, 평균적인 시간복잡도와 관계없음 

### 분할 상환 분석
- WHAT?
    - 함수의 동작을 설명할 때 중요한 분석 방법 중 하나
- WHY?
    - 알고리즘 전체를 보지 않고 최악의 경우만을 살펴 보는 것은 옳지 않다
- HOW?
    - 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태

### 파이썬 자료형
#### 숫자
##### int
- WHAT? 
    - 숫자 정수형으로 int만 제공
- WHY?
    - long과 int 통합
- HOW?
    - 임의 정밀도 지원
- PLUS
    - 임의 정밀도 : 무제한 자릿수를 제공하는 정수형
##### Bool
- WHAT?
    - 논리 자료형, 1 or 0으로 처리되는 int의 서브 클래스
- HOW?
    - ```python True == 1 : True```
#### 매핑
- WHAT?
    - 키와 자료형으로 구성된 복합 자료형, 5장에서 디테일하게 설명
#### 집합
- WHAT?
    - 중복된 값을 갖지 않는 자료형, 5장에서 디테일하게 설명
#### 시퀀스
- WHAT?
    - 수열, 배열의 역할 수행

#### 객체
- WHAT?
    - object 개념
- WHY?
    - 파이썬은 원시타입 대신 객체를 선택함
- HOW?
    - 불변 객체, 가변 객체  
- PLUS
        
|클래스|불변객체|
|:----|:-----|
|bool|O|
|int|O|
|float|O|
|list|X|
|tuple|O|
|str|O|
|set|X|
|dict|X|

#### 불변객체
- WHAT?
    - 고유의 값이 변하지 않는 객체
    - bool, int, float 등
- WHY?
    - 파이썬은 메모리 상의 위치한 객체의 주소를 얻어오는 것
- HOW?
    - 변수는 참조일 뿐이고 실제로 값을 갖고 있는 int, str은 모두 불변 객체
#### 가변객체
- WHAT?
    - 객체의 값이 변경될 수 있는 객체
    - list, set, dict
- HOW?
    - 다른 변수가 참고 있을 때 그 변수의 값 또한 변경됨
    
## 5장. 리스트, 딕셔너리
### 리스트
- WHAT?
    - 순서대로 저장하는 시퀀스이자 변경 가능한 목록
- WHY?
    - 파이썬은 모든 것이 객체이기 떄문에 리스트는 각 객체의 포인터들을 모아놓은 배열임
    - 속도보다 보다 많은 기능을 추가하기 위한 방법을 취함
- HOW?
    - 객체로 되어 있는 모든 자료형을 포인터로 연결

### 딕셔너리
- WHAT?
    - 키/값 구조로 이뤄진 자료구조
- HOW?
    - 입력 순서가 유지, 내부적으로는 해시 테이블로 구현
- PLUS
    - {}로 선언하지만 키값 O : 딕셔너리, 키값 X : set

## 6장. 문자열 조작
- WHAT?
    - 문자열을 변경하거나 분리하는 등의 여러 과정
- WHY?
    - 다양한 분야에서 사용되고 실무에 많음

### 6-1. 유효한 팰린드롬 / leetcode 125

- 슬라이싱 활용
1. re.sub으로 불필요 문자 제거, [정규표현식](추가예정
2. 슬라이싱 활용 [::-1] : 뒤집기)
3. `[::숫자] : 리스트에서 0번째부터 숫자 만큼 건너가면서 추출하기`  
```python  
class Solution:
    def isPalindrome(self, a: str) -> bool:
        a = a.lower()
        a = re.sub('[^a-z0-9]', '', a)

        if a == a[::-1]:
            return True
        else:
            return False
```

- 리스트 + deque 활용하여 최적화
1. `isalnum 숫자인지 확인하는 함수`
2. 새로운 리스트에 거꾸로 추가
3. 비교할 때 deque로 빠르게 popleft할 수 있어서 시간단축  
```python  
class Solution:
    def is_palindrome(self, a: str) -> bool:
        strs: Deque = collections.deque()
        for char in a:
            if char.isalnum():
                strs.append(char.lower())

        while len(strs) > 1:
            if strs.popleft() != strs.pop():
                return False
        return True
```

### 문자열 뒤집기 / leetcode 344
- 슬라이싱 활용
1. s[:]와 같이 플랫폼마다 트릭을 사용해야만 정상 작동하는 경우가 있다. 
```python  
class Solution:
    def reverseString(self, s: List[str]) -> None:
        s[:] = s[::-1]
```

- 내부기능 사용
1. reverse는 반환없이 뒤집음
```python  
class Solution:
    def reverseString(self, s: List[str]) -> None:
        s.reverse()
```

- 투포인터 활용
1. 두 변수를 사용해서 일일히 바꿔주는 방식
```python  
class Solution:
    def reverseString(self, s: List[str]) -> None:
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            right -= 1
            left += 1
```

### 로그 파일 재정렬 / leetcode 937

- 람다 + 연산자 사용
1. `isdigit으로 숫자열인지 확인` [isalnum과 isdigit 차이](https://velog.io/@oaoong/python-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%B2%B4%ED%81%AC-isdigit-isalpha-isalnum-isnumeric-is-decimic-%ED%95%A8%EC%88%98)
2. sort 파라미터 key를 람다함수로 정렬
3. 연산자로 리스트 합치기  
```python  
class Solution:
    def reorderLogFiles(self, logs: List[str]) -> List[str]:
        letter, digit = [], []
        for log in logs:
            if log.split()[1].isdigit():
                digit.append(log)
            else:
                letter.append(log)
                
        letter.sort(key = lambda x: [x.split()[1:], x.split()[0]])
        
        return letter + digit
```

### `가장 흔한 단어 / leetcode 819`

- solution 1 : `re.sub + 리스트컴프리헨션 + Counter`
1. `정규표현식 \w : 단어`
2. `리스트컴프리헨션으로 banned에 있는 단어는 제외하고 리스트형성`
3. counter.most_common 기능으로 가장 많은 단어 찾기
```python  
class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = paragraph.lower()
        paragraph = re.sub('[^\w]', ' ', paragraph)
        words = [word for word in paragraph.split() if word not in banned]  
        
        # counter = Counter(words)
        # return counter.most_common(1)[0][0]
    
        # OR 
        
        counts = collections.defaultdict(int)
        for word in words:
            counts[word] += 1
        return max(counts, key=counts.get)
```

- solution 2 : re.sub + 리스트컴프리헨션 + defaultdict
1. 동일
2. 동일
3. defaultdict으로 딕셔너리 생성해서 key별 count 세기
4. `max함수로 찾되 파라미터 key를 get기능을 활용. get은 딕셔너리 key값의 value를 가져옴`


### `그룹 애너그램 / leetcode 49`

- solution : `dict key값 + 문자정렬`
1. 각 문자들을 sorted() 기능으로 정렬한 후에 딕셔너리 키값으로 넣는다
2. for문으로 정렬된 키값 기준으로 append
3. dict.values() 기능으로 값 추출
- `PLUS`
    - `문자는 sorted('문자') 정렬할 수 있음. 반환값은 list`
    - `dict의 키값은 꼭 숫자나 단순한 것이 아니어도 됨.` 
- 풀이   
```python  
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        anagrams = collections.defaultdict(list)
        
        for word in strs:
            anagrams[''.join(sorted(word))].append(word)
        
        result = list(anagrams.values())
        
        return result
```

### `가장 긴 팰린드롬 / leetcode 5`

- solution : 2중 반복 + max
1. 짝수, 홀수 각각 설정
2. while로 팰린드롬 확인
3. 가장 긴 팰린드롬 추출
```python  
class Solution:
    def longestPalindrome(self, s: str) -> str:
        def expand(left: int, right: int) -> str:
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1
            
            return s[left + 1:right]
        
        if len(s) < 2 or s == s[::-1]:
            return s
        
        result = ''
        
        for i in range(len(s) - 1):
            result = max(result, ''
                            expand(i, i + 1),
                            expand(i, i + 2),
                            key = len)
            
        return result
```

## 7장. 배열

### leetcode 1. Two Sum

- 내풀이
    - 리스트 + in
    - 숫자를 뺀 나머지가 리스트에 있는지 확인  
```python  
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for idx1, num1 in enumerate(nums):
            other = target - num1
            if other in nums[idx1 + 1:]:
                    
                return [idx1, nums[idx1 + 1:].index(other) + idx1 + 1]
```

- 해설과 똑같이 풀었다... 칭찬해

### `42. Trapping Rain Water`

- 내풀이
    - max, min 활용
    - min(max(해당지점 전까지 수), max(해당지점 다음부터 끝까지)) - 해당지점
```python  
class Solution:
    def trap(self, height: List[int]) -> int:

        result = 0
        
        for idx, num in enumerate(height[1:-1]):
            left_max = max(height[:idx + 1])
            right_max = max(height[idx + 1:])
            if left_max > num and right_max > num and min(left_max, right_max) > num:
                result += min(left_max, right_max) - num
                
        return result
```

- solution 1 / `recheck`
    - 스택 + min
    - 스택으로 쌓다가 전 블록보다 큰 길이의 블록이 나오면 전에 있던 블록을 꺼내면서 길이 * 높이 구하기  
```python  
class Solution:
    def trap(self, height: List[int]) -> int:

        stack = []
        volume = 0
        
        for i in range(len(height)):
            while stack and height[i] >= height[stack[-1]]:
                
                top = stack.pop()
                
                if not len(stack):
                    break
                    
                distance = i - stack[-1] - 1
                waters = min(height[i], height[stack[-1]]) - height[top]
                
                volume += distance * waters
                
            stack.append(i)
            
        return volume
```

- solution 2 / `recheck`
    - 양쪽에서 좁혀들어오면서 구하기

- explanation
    1. 양쪽에서 좁혀들어온다
    2. 왼쪽 최고 높이 <= 오른쪽 최고 높이
        - 왼쪽 최고에서 현재 최고를 빼주면 해당 지점의 물 저장량을 구할 수 있음
        - 이게 가능한 이유는 해당지점의 양극의 최고높이는 해당지점의 물저장량을 결정짓기 때문  
  ```python   
  class Solution:
      def trap(self, height: List[int]) -> int:
          if not height:
              return 0
          left = 0
          right = len(height) - 1
          
          max_left = height[left]
          max_right = height[right]
          
          
          cnt = 0
          
          while left < right:
              if max_left <= max_right:
                  left += 1
                  max_left = max(max_left, height[left])
                  cnt += max_left - height[left]
              else:
                  right -= 1
                  max_right = max(max_right, height[right])
                  cnt += max_right - height[right]
          
          return cnt
  ```

### 15. 3Sum

- solution 1
    - 정렬
    - 해당지점의 다른 장소에서 덧셈을 통해 0보다 큰지 작은지에 확인  
```python  
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        
        if len(nums) <= 2:
            return
        
        result = []
        nums.sort()
        
        for i in range(len(nums) - 2):
            
            
            if i > 0 and nums[i] == nums[i - 1]:
                continue
                
            left, right = i + 1, len(nums) - 1
            
            while left < right:
                sum = nums[i] + nums[left] + nums[right]
                
                if sum < 0:
                    left += 1
                elif sum > 0:
                    right -= 1
                else:
                    result.append([nums[i], nums[left], nums[right]])
                    
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                        
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                        
                    left += 1
                    right -= 1
                
        return result
 ```

- solution 2
    - 양수, 음수로 나누기
    - 0이 3개 인것은 별도로 추가
    - 양수와 음수를 더한 것에서 0으로 만드는 수를 구하는데 조건이 있음
        - 양수와 음수와 다른수거나
        - 같은 수 인데 해당숫자가 2개 이상 있을 경우   
    ```python  
    class Solution:
        def threeSum(self, nums: List[int]) -> List[List[int]]:
            res = set()
            vals = Counter(nums)
            positive, negative = [n for n in vals if n > 0], [n for n in vals if n < 0]
            
            if vals[0] > 2:
                res.add((0, 0 ,0))
            for n1 in positive:
                for n2 in negative:
                    c = 0 - (n1 + n2)
                    if c in vals and ((c != n1 and c != n2) or vals[c] > 1):
                        res.add(tuple(sorted([n1, n2, c])))
            return res
    ```

### 561. Array Partition I

- 내풀이
    - 정렬
    - 첫번째 수 만 추출해서 합계  
```python  
class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()
        
        result = sum(nums[::2])
        
        return result
```
- solution
    - 내풀이와 동일
    - 한줄 양식  
```python  
class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        return sum(sorted(nums)[::2])
```

### `238. Product of Array Except Self`

- solution1 / `recheck`
    - 왼쪽부터 오른쪽까지 한칸 밀어서 곱셈하기
    - 오른쪽부터 왼쪽까지 한칸 밀어서 곱셈하기
    - 둘이 곱해주기
    
- explanation
    - 왼쪽부터 오른쪽까지 한칸 밀어서 곱셈하면 각지점은 해당지점의 전 숫자들을 모두 곱한 수가 된다
    - 오른쪽부터 왼쪽까지 한칸 밀어서 곱셈하면 각지점은 해당지점의 전 숫자들을 모두 곱한 수가 된다
    - 이를 한 배열만 사용하기 위해선 별도의 변수를 선언해서 1부터 곱하고 계산  
```python  
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        result = []
        p = 1
        
        for i in range(0, len(nums)):
            result.append(p)
            p *= nums[i]
            
        p = 1
        for i in range(len(nums) - 1, 0 - 1, -1):
            result[i] = result[i] * p
            p *= nums[i]
    
        return result  
```

- 비슷한풀이  
```python  
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1]
        for i in range(len(nums)-1):
            left = res[-1] * nums[i]
            res.append(left)
        right = nums[-1]
        for i in range(len(nums)-2, -1, -1):
            res[i] *= right
            right *= nums[i]
            
        return res
```


### 121. Best Time to Buy and Sell Stock

- solution / `recheck`
    - 최솟값을 저장해서 현재가격과 최소가격의 차 구하기
    
- PLUS
    - `max() 자체가 for문 역할을 하기 때문에 for + max(list)할 경우 이중for문과 같은 성능이 된다.`
```python  
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        result = 0
        min_price = sys.maxsize
        
        for price in prices:
            min_price = min(price, min_price)
            result = max(result, price - min_price)
            
        return result
```


## 8장. 연결리스트

- WHAT?
    - 연결리스트(단일,이중,원형)
- WHY?
    - 삽입과 삭제가 O(1)로 빠름
    - 탐색은 O(N)
    - => 삽입과 삭제가 필요한 연산일 경우 유리함
- HOW?
    - 연속적인 메모리에 저장하는것이 아닌 포인터로 연결시킴

### 234. Palindrome Linked List

- 내풀이
    - 일반 list 사용
    - 순서대로 삽입 후 조여오면서 뺀 것들 비교  
- Explanation
    - 일반 리스트는 동적배열을 하기 때문에 삭제와 삽입 연산시 시간이 O(N)으로 많이 걸린다
    - 해당 문제는 탐색하는 것이 아닌 빼서 비교하는 연산을 사용하기 때문에 연결리스트로 풀이할시 성능이 좋아짐  
```python  
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        
        q: List = []
            
        if not head:
            return True
        
        node = head
        while node:
            q.append(node.val)
            node = node.next
            
        while len(q) > 1:
            if q.pop(0) != q.pop():
                return False
        
        return True
```

> 연결리스트, deque 활용  

- solution 1
    - 연결리스트 사용, `deque는 이중연결리스트`
    - 나머지는 그대로      
  
    ```python 
    class Solution:
        def isPalindrome(self, head: ListNode) -> bool:
            
            q: Deque = collections.deque()
                
            if not head:
                return True
            
            node = head
            while node:
                q.append(node.val)
                node = node.next
                
            while len(q) > 1:
                if q.popleft() != q.pop():
                    return False
            
            return True 
    ```

> 러너활용  

- solution 2 / `recheck`
    - 러너 활용
- Explanation
    - 빠른러너, 느린러너를 활용해 빠른러너가 리스트 끝까지 갔을때 느린러너는 리스트 중간지점에 도착하는 것을 이용
    - 느린러너는 역으로 LINK를 연결함
    - 느린러너가 중간에서 시작하여 REV와 비교  
    - 여기서 REV를 역으로 연결할 수 있는 이유는 REV 다음을 SLOW가 참조하고 있기때문
    ```python  
    def isPalindrome(self, head: ListNode) -> bool:
        
        rev = None
        
        slow = fast = head
        
        #fast가 움직일때마다, slow도 한칸 앞으로, rev도 이전껄 잇는다
        while fast and fast.next:
            fast = fast.next.next
            rev, rev.next, slow = slow, rev, slow.next                
        
        #fast가 홀수이면 slow가 중간지점까지 가지 못하기 때문에
        #slow를 한칸 더 보냄
        if fast:
            slow = slow.next
            
        #슬로우가 리스트끝까지 갈때까지 팰린드롬 검사    
        #and rev 조건은 rev가 None인 지점까지 돌으라는 뜻
        while rev and slow.val == rev.val:
            rev, slow = rev.next, slow.next
            
        return not rev
    ```

> 슬라이싱 활용  

- solution 3
    - 리스트를 담고 슬라이싱 `[::-1] 활용
    ```python  
    class Solution:
        def isPalindrome(self, head: ListNode) -> bool:
            vals = []
            current_node = head
            while current_node is not None:
                vals.append(current_node.val)
                current_node = current_node.next
            return vals == vals[::-1]
    ```

> 재귀함수

- solution 4 / `recheck`
    - 재귀활용
        1. current node가 None일때까지 재귀를 반복/ current node를 끝까지 보내기 위함
        2. 끝까지 보내고나서 재귀들이 하나씩 풀리는 것을 활용해서 역순과 정순을 비교  
        3. 노드 사용시 front_pointer 생성됨  
        ```python 
        class Solution:
        def isPalindrome(self, head: ListNode) -> bool:
    
            self.front_pointer = head
    
            def recursively_check(current_node=head):
                if current_node is not None:
                    if not recursively_check(current_node.next):
                        return False
                    if self.front_pointer.val != current_node.val:
                        return False
                    self.front_pointer = self.front_pointer.next
                return True
    
            return recursively_check()
        ```
  
### `21. Merge Two Sorted Lists`

> iteration

- solution 1
    - iteration 활용
        1. 임의의 노드 생성, 후에 .next로 결과 제출하기 위함
        2. 임의의 노드 복사, .next를 활용하여 값을 저장하기 위함
        3. iteration으로 값비교
        4. `노드가 남은 리스트 연결`, 연결되어 있기때문에 남은 노드만 연결해주면 됨
    ```python 
    class Solution:
        def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
            
            prehead = ListNode(-1)
            
            prev = prehead
            
            while l1 and l2:
                if l1.val > l2.val:
                    prev.next = l2
                    l2 = l2.next
                else:
                    prev.next = l1
                    l1 = l1.next
                prev = prev.next
                
            ### 중요한 표현
            prev.next = l1 if l1 is not None else l2
            
            return prehead.next
    ```
  
  
> 재귀함수  

- solution 2 / `recheck`
    - 재귀활용
        1. l1, l2가 None이면 반대쪽 반환
        2. 값 비교 후 작은 값 반환  
    ```python  
    class Solution:
        def mergeTwoLists(self, l1, l2):
            if l1 is None:
                return l2
            elif l2 is None:
                return l1
            elif l1.val < l2.val:
                l1.next = self.mergeTwoLists(l1.next, l2)
                return l1
            else:
                l2.next = self.mergeTwoLists(l1, l2.next)
                return l2
    ```    
  
> 재귀함수

- solution 3 / `rechekc`
    - 재귀활용, l1에 계속 연결하는 방식
        1. l1이 None이거나 l2값이 l1보다 더 작으면 l1, l2 스왑
        2. l1이 값이 None이 아니면 l1에 값 연결    
        ```python  
        class Solution:
            def mergeTwoLists(self, l1, l2):
                if (not l1) or (l2 and l1.val > l2.val):
                    l1, l2 = l2, l1
                if l1:
                    l1.next = self.mergeTwoLists(l1.next, l2)
                
                return l1      
    ```


### 206. `Reverse Linked List`

> iteration

- solution 1 / `recheck`
    - iteration 사용
        1. prev를 활용해 정순이었던 노드를 역순으로 바꾼다
        2. next를 다음 노드로 보내고, 노드 다음거를 prev로 저장
        3. prev는 현재노드를 저장하고, node는 다음거 저장
    ```python  
    class Solution:
        def reverseList(self, head: ListNode) -> ListNode:
            
            node, prev = head, None
            
            while node:
                next, node.next = node.next, prev
                prev, node = node, next
            
            return prev
    ```

- 변수 할당을 통해서 적용  
```python  
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        
        node, prev = head, None
        
        while node:
            node.next, prev, node = prev, node, node.next
        
        return prev
```
> 재귀함수

- solution 2
    - 재귀활용
    ```python  
    class Solution:
        def reverseList(self, head: ListNode) -> ListNode:
            def reverse(node: ListNode, prev: ListNode = None):
                if not node:
                    return prev
                
                next, node.next = node.next, prev
                return reverse(next, node)
            
            return reverse(head)
    ```

### `2. Add Two Numbers`

> divmod 활용  

- solution / `recheck`
    - divmod, if문 활용
        1. result = head는 같은 주소를 참조하는 것을 활용하여 결과값 제출
        2. l1, l2, carry 더한 것을 divmod(나머지, 몫 반환)를 활용해 다음 노드에 val를 집어넣음    
       ```python  
        class Solution:
            def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
            
                result = head = ListNode(0)
                
                carry = 0
                
                while l1 or l2 or carry:
                    sum = 0
                    
                    if l1:
                        sum += l1.val
                        l1 = l1.next
                    if l2:
                        sum += l2.val
                        l2 = l2.next
                        
                    carry, val = divmod(carry + sum, 10)
                    head.next = ListNode(val)
                    head = head.next
                    
                return result.next
        ```
  
### `24. Swap Nodes in Pairs`

> 연결리스트 next 활용, 값만 변경

- 내풀이
    - next.next 활용    
```python  
    class Solution:
        def swapPairs(self, head: ListNode) -> ListNode:
            
            if not head or not head.next:
                return head
            
            result = first = head
            
            second = first.next
            
            while first and second:
                first.val, second.val = second.val, first.val
                if not first.next.next or not second.next.next:
                    return result
                
                first, second = first.next.next, second.next.next
```    

> 내풀이와 동일

- solution 1
    - 내풀이와 동일, 단 코드가 간결하게 작성     
```python 
    class Solution:
        def swapPairs(self, head: ListNode) -> ListNode:
            
            cur = head
        
            while cur and cur.next:
                cur.val, cur.next.val = cur.next.val, cur.val
                cur = cur.next.next
                
            return head
```

> 노드 자체를 바꿈, 반복구조  

- solution 2 / `recheck`  
    - head와 head다음것을 지정하여 스왑해주는 형태                  
    ```python  
        class Solution:
            def swapPairs(self, head: ListNode) -> ListNode:
                
                result = prev = ListNode(0)
                
                prev.next = head
                
                while head and head.next:
                    b = head.next
                    head.next = b.next
                    b.next = head
                    
                    prev.next = b
                    
                    head = head.next
                    prev = prev.next.next
    ```

> 재귀형태

- solution 3 / `recheck`
    - 재귀함수
        1. head와 바꿀 포인터 p 생성
        2. head.next는 스왑된 값을 받고 이어줌
        3. 스왑된 p값을 리턴  
        ```python  
            class Solution:
                def swapPairs(self, head: ListNode) -> ListNode:
                    
                    p = head.next
                    head.next = self.swapPairs(p.next)
                    p.next = head
                    return p
                
                return head
        ```
  

### `328. Odd Even Linked List`

> next.next 활용  

- solution / `recheck`
    - next포인터 활용
        1. 나중에 홀수와 짝수를 이어줄 even_head를 지정
        2. odd와 even 두개단위로 넘어감
        3. while 조건식 even, even.next
- explanation
    - 여기서 next.next가 가능한 이유는 even.next가 존재하면 even.next.next는 없어도 none이기 때문    
    ```python 
    class Solution:
        def oddEvenList(self, head: ListNode) -> ListNode:
            if not head:
                return head
            
            odd = head
            even = even_head = head.next
            
            while even and even.next:
                odd.next, even.next = odd.next.next, even.next.next
                odd, even = odd.next, even.next
            
            odd.next = even_head
            
            return head
    ```

### `92. Reverse Linked List II`
> 투포인터 사용

- solution
    - 투포인터 사용, start, end를 고정해서 반복시에 포인터를 바꾼다     
    ```python  
    class Solution:
        def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
            root = start = ListNode(0)
            
            root.next = head 
            
            for _ in range(left - 1):
                start = start.next
            end = start.next
            
            for _ in range(right - left):
                temp, start.next, end.next = start.next, end.next, end.next.next
                start.next.next = temp
                
            return root.next
    ```
  
## 9장. 스택, 큐

- What : 스택, FILO
- Why : ctrl + z 연산, 애플리케이션 개발에 쓰임
- How : 파이썬 리스트, 연결리스트 
        - 연결리스트는 삽입 삭제가 O(1)
        - 파이썬리스트는 동적크기조절로 O(N)

### 20. Valid Parentheses

> 스택 + 조건문 

- 내풀이
    - 조건문 활용
        1. ), }, ] 가 들어오면 바로전 stack 확인
        2. 바로전문자와 매칭이 되지 않거나, stack 개수가 0개 이상이면 False  
        ```python  
            class Solution:
                def isValid(self, s: str) -> bool:
                    stack = []
                    
                    for i in s:
                        if i == ']':
                            if not stack or stack[-1] != '[':
                                return False
                            if stack[-1] == '[':
                                stack.pop()
                                continue
                        elif i == '}':
                            if not stack or stack[-1] != '{':
                                return False
                            if stack[-1] == '{':
                                stack.pop()
                                continue                
                        elif i == ')':
                            if not stack or stack[-1] != '(':
                                return False
                            if stack[-1] == '(':
                                stack.pop()
                                continue      
                        
                        stack.append(i)
                        
                    return len(stack) == 0
        ```

> 스택 + 딕셔너리
   
- solution / `recheck`
    - 딕셔너리를 만들어서 각 괄호와 대응하는 것을 추출하여 비교  
    ```python  
        class Solution:
            def isValid(self, s: str) -> bool:
                
                table = {
                        ')' : '(',
                        '}' : '{',
                        ']' : '['
                }
                
                stack: Deque = collections.deque()
                
                for char in s:
                    if char not in table:
                        stack.append(char)
                    elif not stack or table[char] != stack.pop():
                        return False
                    
                return len(stack) == 0
    ```


### `316. Remove Duplicate Letters`

> set + Counter + 스택

- solution 1 / `recheck`
    1. Counter를 활용해 문자별 숫자를 파악
    2. set을 활용해 전에 추가되었던 문자인지 확인
    3. 스택을 활용해 순서적으로 마지막에 온 문자를 확인하여 이전에 추가된 문자가 후에도 나올것인지 Counter개수를 통해 확인
- Explanation
    - set, 스택을 동시에 활용한 이유
        - set는 중복제거로 이전에 추가되었던 내역들을 확인하는데 사용할 수 있음
        - stack은 for loop중 최근에 추가된 것을 슬라이싱을 이용해 확인할 수 있음  
        ```python  
            class Solution:
                def removeDuplicateLetters(self, s: str) -> str:
                    counter, seen, stack = collections.Counter(s), set(), []
                    
                    for char in s:
                        counter[char] -= 1
                        if char in seen:
                            continue
                            
                        while stack and char < stack[-1] and counter[stack[-1]] > 0:
                            seen.remove(stack.pop())
                        stack.append(char)
                        seen.add(char)
                        
                    return ''.join(stack)
        ```
- PLUS in SET
    - set는 한개 추가할때 : add() 사용
    - 여러개 추가할때 : update([]) 사용
    - 제거할때 : remove() 사용
    - [set 활용법](https://thispointer.com/python-set-remove-single-or-multiple-elements-from-a-set/)
     
> 재귀활용

- solution 2 / Hard....
    1. 정렬된 set를 for loop로 돌려서 애초에 순서가 정렬된 결과를 얻는다
    2. index를 활용해 해당문자가 처음나온곳부터 끝까지와 확인하려는 구간 전체를 set로 비교해 같은지 확인
        - 같으면 해당문자가 와도 된다는 뜻
        - 다르면 해당문자가 앞에오면 순서적으로 모순이 있다는 뜻
    3. return값 : 해당문자와 나머지 탐색해야할 구간
        - 여기서 의문, for문으로 재귀를 돌리면 return값이 합쳐서 return 되는것인가?  
    ```python  
        class Solution:
            def removeDuplicateLetters(self, s: str) -> str:
                
                #집합으로 정렬
                for char in sorted(set(s)):
                    suffix = s[s.index(char):]
                    
                    if set(s) == set(suffix):
                        return char + self.removeDuplicateLetters(suffix.replace(char, ''))
                    
                return ''
    ```

### `739. Daily Temperatures` ***
> stack

- solution / `recheck`
    1. 스택으로 쌓다가 다음수가 이전수보다 크면 같거나 작을때까지 빼기
    2. enumerate로 추출된 idx넘버를 저장하여 현재시점과 작은 시점을 빼서 계산하기    
- Explanation
    - 해당문제는 결과들이 각각 독립적인 입장을 취하고 있음으로 정답배열을 미리 선언하는게 좋음  
    ```python  
        class Solution:
            def dailyTemperatures(self, temperatures: List[int]) -> List[int]:                
                answer = [0] * len(temperatures)                
                stack = []                
                for idx, tem in enumerate(temperatures):
                    #현재 온도가 스택의 마지막 온도보다 높다면 일자 구하기                
                    while stack and temperatures[stack[-1]] < tem:
                        last = stack.pop()
                        answer[last] = idx - last
                    stack.append(idx)
                    
                return answer
    ```
 
### 225. Implement Stack using Queues
> 큐로 스택구현

- solution 
    - deque를 선언해서  
    ```python  
        class MyStack:
        
            def __init__(self):
                """
                Initialize your data structure here.
                """
                self.q = collections.deque()
                
        
            def push(self, x: int) -> None:
                """
                Push element x onto stack.
                """
                self.q.append(x)
                
                for _ in range(len(self.q) - 1):
                    self.q.append(self.q.popleft())
        
            def pop(self) -> int:
                """
                Removes the element on top of the stack and returns that element.
                """
                return self.q.popleft()
        
            def top(self) -> int:
                """
                Get the top element.
                """
                return self.q[0]
        
            def empty(self) -> bool:
                """
                Returns whether the stack is empty.
                """
                return len(self.q) == 0
    ```
###
> 스택으로 큐구현

- solution
    1. 스택으로 큐를 규현하려면 두개의 리스트가 필요
        - 담아두었다가 -> 다른데로 옮기면서 역순으로 정렬
    ```python  
        class MyQueue:
        
            def __init__(self):
                """
                Initialize your data structure here.
                """
                self.input = []
                self.output = []
        
            def push(self, x: int) -> None:
                """
                Push element x to the back of queue.
                """
                self.input.append(x)
        
            def pop(self) -> int:
                """
                Removes the element from in front of queue and returns that element.
                """
                self.peek()
                return self.output.pop()
        
            def peek(self) -> int:
                """
                Get the front element.
                """
                if not self.output:
                    while self.input:
                        self.output.append(self.input.pop())
                return self.output[-1]
            
            def empty(self) -> bool:
                """
                Returns whether the queue is empty.
                """
                return self.input == [] and self.output == []
    ```

### 622. Design Circular Queue
> 원형 큐 구현 with 배열

- solution 
    - 배열로 구성했을때 공간을 재활용한다는 이점이 있음
    1. 투포인터를 선언하여 front, rear의 위치를 잡음
    2. 각 명령에 맞게 한칸씩 이동  
    ```python  
        class MyCircularQueue:
        
            def __init__(self, k: int):
                self.q = [None] * k
                self.maxlen = k
                self.p1 = 0
                self.p2 = 0
        
            def enQueue(self, value: int) -> bool:
                if self.q[self.p2] is None:
                    self.q[self.p2] = value
                    self.p2 = (self.p2 + 1) % self.maxlen
                    return True
                else:
                    return False
                
        
            def deQueue(self) -> bool:
                if self.q[self.p1] is None:
                    return False
                else:
                    self.q[self.p1] = None
                    self.p1 = (self.p1 + 1) % self.maxlen
                    return True
        
            def Front(self) -> int:
                return self.q[self.p1] if self.q[self.p1] is not None else -1
        
            def Rear(self) -> int:
                return self.q[self.p2 - 1] if self.q[self.p2 - 1] is not None else -1
        
            def isEmpty(self) -> bool:
                return self.p1 == self.p2 and self.q[self.p1] is None
        
            def isFull(self) -> bool:
                return self.p1 == self.p2 and self.q[self.p1] is not None
    ```
  
## 10장. 데크, 우선순위 큐

- What
    - 데크
- Why
    - 양쪽 끝에서 삽입, 삭제 연산이 간으함
- How
    - 이중연결리스트
    - collections.deque()

- What
    - 우선순위 큐
- Why
    - 우선순위대로 정렬함
- How
    - 힙

### 23. Merge k Sorted Lists
> 배열생성 -> 연결리스트로 잇기

- solution
    1. 값만 저장하는 배열을 따로 생성하여 값을 저장한다
    2. 값을 정렬한후 연결리스트를 생성해서 잇는다  
    ```python  
        class Solution:
            def mergeKLists(self, lists: List[ListNode]) -> ListNode:
                
                self.nodes = []
                head = point = ListNode(0)
                for l in lists:
                    while l:
                        self.nodes.append(l.val)
                        l = l.next
                for x in sorted(self.nodes):
                    point.next = ListNode(x)
                    point = point.next
                return head.next
    ```

## 11장. 해시테이블

- What
    - 해싱 : 테이블을 인덱싱하기 위해 함수를 사용하는 것
- Why
    - 대부분의 연산이 분할 상환 분석에 따라서 O(1)임
    - 최적 검색이 필요한 분야
- How
    - 충돌방지 : 충돌이 많아지면 불필요한 연산이 많아짐
        - 로드팩터 (데이터개수 / 버킷의 개수)
        - 개별 체이닝 : 충돌시 연결리스트로 연결
        - 오픈 어드레싱 : 충돌된 버킷 바로 다음 버킷에 저장
        - 로드펙터 80%까지는 오픈 어드레싱이 효율적임, 파이썬은 오픈 어드레싱으로 되어 있음   
  
###
> 연결리스트 + 해시테이블 + 개별체이싱

- solution
    1. 노드 class 선언
    2. defaultdict로 검색시 바로 생성할 수 있게 ADT 설정
    3. key % self.size 해시함수 설정  
    
    ```python  
        class ListNode:
            def __init__(self, key = None, value = None):
                self.key = key
                self.value = value
                self.next = None
                
        class MyHashMap:
        
            def __init__(self):
           
                #크기 설정
                self.size = 1000
                #해쉬맵 ADT 설정
                self.table = collections.defaultdict(ListNode)
                
        
            def put(self, key: int, value: int) -> None:
        
                index = key % self.size
                #인덱스에 노드가 없다면 삽입 후 종료
                if self.table[index].value is None:
                    self.table[index] = ListNode(key, value)
                    return
                
                #인덱스에 노드가 있다면 연결리스트처리(개별체이싱)
                p = self.table[index]
                while p:
                    if p.key == key:
                        p.value = value
                        return
                    if p.next is None:
                        break
                    p = p.next
                p.next = ListNode(key, value)
        
            def get(self, key: int) -> int:
        
                index = key % self.size
                #조회하는 즉시 생성되기 때문에 값이 None인지 찾아야함
                if self.table[index].value is None:
                    return -1
        
                #노드가 존재할때 일치하는 키 탐색
                p = self.table[index]
                while p:
                    if p.key == key:
                        return p.value
                    p = p.next
                return -1
            
            def remove(self, key: int) -> None:
                index = key % self.size
                
                #조회하는 노드가 없는 경우
                if self.table[index].value is None:
                    return
                
                # 인덱스의 첫 번째 노드일 경우
                # 인덱스가 가리키는 노드를 빈노드로 하거나 다음노드를 가리키게 함
                p = self.table[index]
                if p.key == key:
                    self.table[index] = ListNode() if p.next is None else p.next
        
                # 연결리스트 노드 삭제
                # 다음노드와 다다음 노드를 연결
                prev = p
                while p:
                    if p.key == key:
                        prev.next = p.next
                        return
                    prev, p = p, p.next
                
    ```
  
### 
> 해시테이블 - 딕셔너리 사용

```python  
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        
        freqs = {}
        
        for char in stones:
            if char not in freqs:
                freqs[char] = 1
            else:
                freqs[char] += 1
                
        count = 0
        for char in jewels:
            count += freqs.get(char, 0)
            
        return count
```

> set 사용

```python  
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        
        Jset = set(jewels)
        return sum(s in Jset for s in stones)
```

> 문자열 사용

```python  
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        
        return sum(stone in jewels for stone in stones)
```

- 성능은 디셔너리를 이용한 hash table이 가장 좋음


### 
> 딕셔너리, enumerate 활용

- solutions
    1. 딕셔너리에 문자별 위치갱신
    2. 위치가 있으면 start 갱신
    3. 이전에 없던거면 길이 측정  
    ```python  
        class Solution:
            def lengthOfLongestSubstring(self, s: str) -> int:        
                
                start = 0
                string = {}
                
                result = 0
                for idx, char in enumerate(s):
                    if char in string and string[char] >= start:
                        start = string[char] + 1
                    else:
                        result = max(result, idx - start)
        
                    string[char] = idx
                        
                return result
    ```

### 347. Top K Frequent Elements

> Counter 사용

- 내풀이
    ```python  
        class Solution:
            def topKFrequent(self, nums: List[int], k: int) -> List[int]:
                counter = collections.Counter(nums)
                
                count = [c for c in counter.items()] 
                
                count.sort(key = lambda x: x[1], reverse = True)
                
                result = [key for key, value in count[:k]]
                return result
    ```
> 파이써닉 + most_common + zip

- solution
    ```python  
        class Solution:
            def topKFrequent(self, nums: List[int], k: int) -> List[int]:
                return list(zip(*collections.Counter(nums).most_common(k)))[0]
    ```
  
  
## 12장. 그래프
- `all recheck`

- What
    - 일부의 쌍들이 영관되어 있는 객체 집합 구조
- Why
    - 정점과 간선을 활용해 경로 문제를 해결할 수 있음
- How
    - BFS
        - 큐
    - DFS
        - 재귀
        - 스택 
    - 백트랙킹
        - 한번 가보고 가능성이 없으면 버리기
        - 브루트포스와 유사하나 브루트포스는 한번가본데를 또간다
        - 따라서, 백트랙킹으로 인한 가지치기는 탐색을 최적화할 수 있다.   
  
### 200. Number of Islands
> DFS

- solution
    1. bfs사용
    2. 이중for문으로 아일랜드 탐색  
    - version 1
        ```python  
            class Solution:
                def numIslands(self, grid: List[List[str]]) -> int:
                    def dfs(x, y):
                        
                        if 0 <= x < len(grid) and 0 <= y < len(grid[-1]) and grid[x][y] == '1':
                            
                            grid[x][y] = 0
                            dfs(x + 1, y)
                            dfs(x - 1, y)
                            dfs(x, y + 1)
                            dfs(x, y - 1)
                            
                    
                    result = 0
                    for i in range(len(grid)):
                        for j in range(len(grid[0])):
                            if grid[i][j] == '1':
                                dfs(i, j)
                                result += 1 
                    
                    return result
        ```
- 같은 풀이를 더 짧은 코드로 구현
- 하지만, 공간, 시간복잡도는 비효율적임  
- version 2
    ```python  
        class Solution:
            def numIslands(self, grid: List[List[str]]) -> int:
                def dfs(r, c):
                    if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] == '0':
                        return 0
                    
                    grid[r][c] = '0'
                    
                    for i, j in zip((r - 1, r + 1, r, r), (c, c, c - 1, c + 1)):
                        dfs(i, j)
                    
                    return 1
                
                return sum(dfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])))            
     ``` 
      
### 17. Letter Combinations of a Phone Number

> DFS

- 내풀이 / 문자열처리 문제와 동일  
  ```python  
    class Solution:
        def letterCombinations(self, digits: str) -> List[str]:
            def dfs(char, digits):
                if not digits:
                    result.append(char)
                    return 
                
                for i in e[digits[0]]:
                    dfs(char + i, digits[1:])
                    
            #예외처리
            if not digits:
                return []
            
            e = {
                '2': ['a', 'b', 'c'],
                '3': ['d', 'e', 'f'],
                '4': ['g', 'h', 'i'],
                '5': ['j', 'k', 'l'],
                '6': ['m', 'n', 'o'],
                '7': ['p', 'q', 'r', 's'],
                '8': ['t', 'u', 'v'],
                '9': ['w', 'x', 'y', 'z'],
            }
            
            result = []
            dfs('', digits)
            
            return result
  ```

- solution  
```python  
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        def dfs(index, path):
            if len(path) == len(digits):
                result.append(path)
                return
            
            for i in range(index, len(digits)):
                for j in dic[digits[i]]:
                    dfs(i + 1, path + j)
                    
        #예외처리
        if not digits:
            return []
        
        dic = {
            '2': ['a', 'b', 'c'],
            '3': ['d', 'e', 'f'],
            '4': ['g', 'h', 'i'],
            '5': ['j', 'k', 'l'],
            '6': ['m', 'n', 'o'],
            '7': ['p', 'q', 'r', 's'],
            '8': ['t', 'u', 'v'],
            '9': ['w', 'x', 'y', 'z'],
        }
        
        result = []
        
        dfs(0, "")
        
        return result      
```

### 46. Permutations / `all recheck`

> DFS, 재귀

- solution 1  
```python  
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        
        result = []
        prev_elements = []
        
        def dfs(elements):
            if not elements:
                result.append(prev_elements[:])
                
            for e in elements:
                next_elements = elements[:]
                next_elements.remove(e)
                
                prev_elements.append(e)
                dfs(next_elements)
                prev_elements.pop()
                
        dfs(nums)
        return result
```
> 재귀

- solution 2  
```python  
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def backtrack(first = 0):
            # if all integers are used up
            if first == n:  
                output.append(nums[:])
            for i in range(first, n):
                # place i-th integer first 
                # in the current permutation
                nums[first], nums[i] = nums[i], nums[first]
                # use next integers to complete the permutations
                backtrack(first + 1)
                # backtrack
                nums[first], nums[i] = nums[i], nums[first]
        
        n = len(nums)
        output = []
        backtrack()
        return output
```

> DFS, 재귀

- solution 3  
```python  
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        self.dfs(nums, [], res)
        return res

    def dfs(self, nums, path, res):
        if not nums:
            res.append(path)
            # return # backtracking
        for i in range(len(nums)):
            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)
```

### 77. Combinations / `recheck`
> DFS, 재귀

```python  
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        result = []
        
        def dfs(elements, start: int, k: int):
            if k == 0:
                result.append(elements[:])
                return

            for i in range(start, n + 1):
                elements.append(i)
                dfs(elements, i + 1, k - 1)
                elements.pop()
        
        dfs([], 1, k)
        return result
```

```python  
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        def backtrack(first = 1, curr = []):
            if len(curr) == k:
                output.append(curr[:])
                
            for i in range(first, n + 1):
                curr.append(i)
                backtrack(i + 1, curr)
                curr.pop()
                
        output = []
        backtrack()
        return output
```

### 39. Combination Sum / `recheck`
> DFS, 재귀

- solution
    - 목표하는 합계에 도달하는 조합 추출
        - 목표합계에서 원소들을 빼면서 == 0, < 0으로 확인
    1. dfs로 설정
        - 한없이 빼는 것을 방지하기 위해 < 0, == 0으로 재귀종류
    2. 자기자신을 포함해서 연달아 합계
        - 파라미터 인자를 전할때 i + 1이 아닌 i  
    ```python  
        class Solution:
            def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
                result = []
                
                def dfs(csum, index, path):
                    if csum < 0:
                        return
                    elif csum == 0:
                        result.append(path)
                        return
                    
                    for i in range(index, len(candidates)):
                        dfs(csum - candidates[i], i, path + [candidates[i]])
        
                dfs(target, 0, [])
                
                return result
    ```

- `***` 위의 풀이와 방식은 비슷함
    - 하지만 속도에서 가장큰 차이점이 있음
        - 위 풀이는 for문 돌려 재귀에 들어감 -> 호출을 많이함
        - 아래 풀이는 for문을 돌려 불필요한 것은 바로 브레이크  
    ```python  
        class Solution:
            def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
                res = []
                def dfs(tmplst, candidates, target):
                    for i, c in enumerate(candidates):
                        d = target - c
                        if d == 0:
                            res.append(tmplst + [c])
                        elif d > 0:
                            dfs(tmplst + [c], candidates[i:], d)
                        else:
                            break
                dfs([], sorted(candidates), target)
                return res
    ```
  
### 39. Combination Sum / `recheck`
> DFS, 재귀

- 내풀이
    - 조합문제 + 변경되는 k값
```python  
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        
        result = []
        
        def dfs(elements, start, k):
            if k == 0:
                result.append(elements[:])
                return
            
            for i in range(start, len(nums)):
                elements.append(nums[i])
                dfs(elements, i + 1, k - 1)
                elements.pop()
                
        for i in range(len(nums) + 1):
            dfs([], 0, i)
        
        return result
```

> DFS, 재귀

- solution
    - 조합을 할때 모든 노드의 조합을 살피기 때문에 굳이 제약조건 없이 모든것을 결과에 더해주면 됨  
    ```python  
        class Solution:
            def subsets(self, nums: List[int]) -> List[List[int]]:
                
                result = []
                
                def dfs(start, path):
                    result.append(path[:])
                    
                    for i in range(start, len(nums)):
                        dfs(i + 1, path + [nums[i]])
                        
                
                dfs(0, [])
                
                return result
    ```
  
### 78. Subsets / `recheck`
> DFS, 재귀

- solution 1
    1. 순서정렬된 ticket을 딕셔너리로 저장하기
    2. dfs로 타고타고 들어가서 pop()하고 route에 추가하기
    3. 역순으로 결과 출력  
    ```python  
        class Solution:
            def findItinerary(self, tickets: List[List[str]]) -> List[str]:
                
                graph = collections.defaultdict(list)
                for x in sorted(tickets):
                    graph[x[0]].append(x[1])
                    
                route = []
                def dfs(x):
                    while graph[x]:
                        dfs(graph[x].pop(0))
                    route.append(x)
                
                dfs('JFK')
                
                return route[::-1]           
    ```
  
> 스택

- solution 2/ `recheck`이긴하나 내가 사용할 수 있는 방법일지는 모르겠음
    1. 딕셔너리로 ticket 저장
    2. JFK를 시작으로 여행을 쌓음
    3. 중간에 통로가 막힐수도 있음으로 쌓은거를 다시 다른곳에 쌓음
    4. 역순으로 결과 출력  
    ```python 
        class Solution:
            def findItinerary(self, tickets: List[List[str]]) -> List[str]:
                
                graph = collections.defaultdict(list)
                
                for a,b in sorted(tickets):
                    graph[a].append(b)
                    
                route, stack = [], ['JFK']
                while stack:
                    while graph[stack[-1]]:
                        stack.append(graph[stack[-1]].pop(0))
                    route.append(stack.pop())
                    
                return route[::-1]   
    ```    
    
### 332. REconstruct ltinerary
> DFS, 재귀

- solution 
    1. 각 노드별로 연결되어 있는 정보를 dict에 저장
    2. 노드별로 연결되어 있는 것을 dfs 파고파고 들어간다
        - 방문중인 노드를 재방문하는 일이 생기면 False
        - 방문기록을 남겨서 다른 노드를 통해서 방문하는 곳은 바로 패스  
    ```python  
        class Solution:
            def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
                graph = collections.defaultdict(list)
                for key, value in prerequisites:
                    graph[key].append(value)
                    
                traced = set()
                visited = set()
                #dfs로 타고타고 들어가서 최초에 타고 들어간 노드가 추가될 일이 생기면 False
                def dfs(node):
                    if node in traced:
                        return False
                    if node in visited:
                        return True
                    
                    traced.add(node)
                    for i in graph[node]:
                        if not dfs(i):
                            return False
                    traced.remove(node)
                    visited.add(node)
                    
                    return True
                
                for node in list(graph):
                    if not dfs(node):
                        return False
                    
                return True
    ```
   
## 13장. 최단경로 문제
- `all recheck`

- What
    - 각 정점들의 혹인 일부를 거치는데 정점의 값의 합이 최소인 것
- Why
    - 경로 최적화를 하기 위함
- How
    - 우선순위 큐, BFS
 
### 743. Network Delay Time / `recheck`

> BFS, heapq, 다익스트라

- solution 1
    1. 딕셔너리 저장, 방문할 노드저장할 딕셔너리 선언
    2. 들렸는지 확인
        - 들렸으면 패스(왜냐 이미 들려서 )
```python  
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        graph = collections.defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))
        
        Q = [(0, k)]
        dist = collections.defaultdict(int)
        
        while Q:
            time, node = heapq.heappop(Q)
            #이미 들린 노드인지 확인
            if node not in dist:
                dist[node] = time
                for v, w in graph[node]:
                    #시간업데이트, 이제까지 걸린시간 + w
                    alt = time + w
                    #노드별로 시간 저장
                    #최소힙으로 자동적으로 최소순으로 전달해줌
                    heapq.heappush(Q, (alt, v))
        
        return max(dist.values()) if len(dist) == n else -1
```

> DFS, 재귀

- solution 2
    - 확실히 BFS보다 시간이 훨씬 오래걸린다.  
    - 최단경로는 BFS로 구현하자.  
```python  
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        graph = collections.defaultdict(list)
        for u, v, w in times:
            graph[u].append((w, v))

        dist = {node: float('inf') for node in range(1, n + 1)}

        def dfs(node, elapsed):
            if elapsed >= dist[node]: return
            dist[node] = elapsed
            for time, nei in sorted(graph[node]):
                dfs(nei, elapsed + time)

        dfs(k, 0)
        ans = max(dist.values())
        return ans if ans < float('inf') else -1
```

### / `recheck`

> BFS, 다익스트라

- solution
    1. 딕셔너리에 정보 저장
    2. 방문했는지 확인하기 위한 딕셔너리 선언
    3. 방문수를 카운트하는데 더 오래 걸린거면 패스
        - 이미 heappush에서 최소 비용을 업데이트 했음
        - 덜 걸린 경로가 들어오면, count와 cost를 다시 측정해야하기 때문에 지나갔던 노드들 재방문
    4. 위 작업 반복
        - 도착하려는 노드가 있을 경우 return cost
        - 없을경우 return -1  
    ```python  
        #다익스트라 + BFS
        class Solution:
            def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
                graph = collections.defaultdict(dict)
                for u, v, w in flights:
                    graph[u][v] = w
  
                Q = [(0, src, k + 1)]
                vis = [0] * n
                while Q:
                    cost, node, count = heapq.heappop(Q)
                    if node == dst:
                        return cost
                    # 이미 방문했던 노드인데, 이전과 비교했을때 더 짧게 트립했는데 확인
                    if vis[node] >= count:
                        continue
                    vis[node] = count
                    for y, dw in graph[node].items():
                        heapq.heappush(Q, (cost+ dw, y, count - 1))
                return -1  
    ```
  
## 14.트리
- `tree all recheck`

- What
    - 계층형 트리 구조를 시뮬레이션 하는 추상자료형
    - 루트 값과 부모-자식관계의 서브트리로 구성
    - 트리 vs 그래프
        - 트리는 순환 구조를 갖지 않는 그래프
        - 트리는 부모가 하나
- Why
    - 계층형 그래프를 사용하기 위해서
- How
    - 재귀, bfs 등
    
### 104. Maximum Depth of Binary Tree / `recheck`

> 재귀

- solution 2
    1. 1 + ((None or not None) or (None or not None))로 뎁스 계산  
    ```python 
        class Solution:
            def maxDepth(self, root: TreeNode) -> int:
                #더큰 노드값을 타고들어가서 계산: 존재하는지만 파악하는 것이기 때문에 둘다 None값이 아닐때까지 확인하는 방법
                # +1이 실질적으로 depth를 확인하는 것
                # 1 + ((None or None) or (None or None))
                return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right)) if root else 0
    ```

> BFS

- solution 2
    1 deque를 이용해서 큐에서 pop하면서 None값이 될때까지 계산  
    ```python  
        class Solution:
            def maxDepth(self, root: TreeNode) -> int:
                return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right)) if root else 0
                 
                queue = collections.deque([root])
                depth = 0
                
                while queue:
                    depth += 1
                    for _ in range(len(queue)):
                        cur_root = queue.popleft()
                        if cur_root.left:
                            queue.append(cur_root.left)
                        if cur_root.right:
                            queue.append(cur_root.right)
                    
                    return depth
    ```

### 543. Diameter of Binary Tree / `recheck`
> 재귀, 트리

- solution
    1. 재귀적으로 왼쪽과 오른쪽을 계속 타고 들어가는 패턴 생성
    2. None값인 노드로 갈경우 -1 반환 / 정이진트리에서 패널티를 주기 위함
    3. self.longest는 해당위치에서 오른쪽에서 왼쪽까지의 거리: +2
    4. return은 left, right중에 더 큰것 + 1
```python  
class Solution:
    longest: int = 0
    
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        
        def dfs(node: TreeNode) -> int:
            if not node:
                return -1
            
            left = dfs(node.left)
            right = dfs(node.right)
            #현재 가장 긴 거리
            self.longest = max(self.longest, left + right + 2)
            #리프노드에서 현재 노드까지의 거리
            return max(left, right) + 1
            
        dfs(root)
        
        return self.longest     
```

### 104. Maximum Depth of Binary Tree

- solution
    - 같은 값의 노드들끼리의 최대거리 구하기
    1. left, right를 계속 타고 내려감
    2. node와 node.left 혹은 node와 node.right의 값이 같은지 확인
        - 같으면 + 1
        - 다르면 0
    3. return값을 그냥 left값을 올려야함
        - 이전처럼 depth를 구하는 것이 아니기 때문에 그대로 올려서 재귀적으로 값이 같은지 확인해야함  
    ```python 
        class Solution:
            result: int = 0
                
            def longestUnivaluePath(self, root: TreeNode) -> int:
                def dfs(node):
                    if not node:
                        return 0
                    
                    left = dfs(node.left)
                    right = dfs(node.right)
                    
                    if node.left and node.left.val == node.val:
                        left += 1
                    else:
                        left = 0
                    
                    if node.right and node.right.val == node.val:
                        right += 1
                    else:
                        right = 0
                        
                    self.result = max(self.result, left + right)
                    
                    return max(left, right)
                
                dfs(root)
                
                return self.result
    ```

### 226. Invert Binary Tree
> 다중할당, 전위순회

- solution 1
    - 파이써닉한 풀이
    1. 다중할당으로 스왑
    2. return으로 값올리기  
    ```python 
        class Solution:
            def invertTree(self, root: TreeNode) -> TreeNode:
                if root:
                    root.right, root.left = self.invertTree(root.left), self.invertTree(root.right)
                    return root
    ```

> BFS, 전위순회

- solution 2
    - popleft 사용해서 부모부터 스왑
    1. 부모빼서 다중할당으로 스왑
    2. while 사용으로 queue가 없을때까지 반복      
    ```python 
        class Solution:
            def invertTree(self, root: TreeNode) -> TreeNode:
                queue = collections.deque([root])
                
                while queue:
                    node = queue.popleft()
                    
                    if node:
                        node.left, node.right = node.right, node.left
                        
                        queue.append(node.left)
                        queue.append(node.right)
                        
                return root   
    ```
> DFS, 전위순회

- solution 2
    - pop 사용해서 부모부터 스왑
    1. 부모빼서 다중할당으로 스왑
    2. while 사용으로 stack가 없을때까지 반복      
    ```python 
        class Solution:
            def invertTree(self, root: TreeNode) -> TreeNode:
                stack = collections.deque([root])
                
                while stack:
                    node = stack.pop()
                    
                    if node:
                        node.left, node.right = node.right, node.left
                        
                        stack.append(node.left)
                        stack.append(node.right)
                        
                return root   
    ```   
> DFS, 후위순회

- solution 2
    - pop 사용해서 부모부터 스왑
    1. 부모빼서 다중할당으로 스왑
    2. while 사용으로 stack가 없을때까지 반복      
    ```python 
        class Solution:
            def invertTree(self, root: TreeNode) -> TreeNode:
                stack = collections.deque([root])
                
                while stack:
                    node = stack.pop()
                    
                    if node:
                        stack.append(node.left)
                        stack.append(node.right)
  
                        node.left, node.right = node.right, node.left
                return root   
    ``` 
  
### 617. Merge Two Binary Trees
> DFS, 재귀

- solution 1
    1. 양쪽트리가 None이 아니라면
        - 새로운 노드를 설정, 값은 둘의 합
        - left포인터로 재귀적으로 left끼리 설정
        - right 마찬가지
    2. 둘 중 하나가 None
        - return으로 둘 하나를 보내면 됨, `or` 사용  
    ```python  
        class Solution:
            def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
                
                if root1 and root2:
                    node = TreeNode(root1.val + root2.val)
                    node.left = self.mergeTrees(root1.left, root2.left)
                    node.right = self.mergeTrees(root1.right, root2.right)
                    return node
                else:
                    return root1 or root2
    ```
   
> BFS            

- solution 2
    1. root1을 업데이트
    2. roo1에 없으면 root2거를 넣어줌  
    ```python  
        class Solution:
            def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
                
                if root1 is None:
                    return root2
                
                stack = [(root1, root2)]
                while stack:
                    t1, t2 = stack.pop()
                    if t2 is None:
                        continue
                    t1.val += t2.val    
                    
                    if t1.left is None:
                        t1.left = t2.left
                    else:
                        stack.append((t1.left, t2.left))
                        
                    if t1.right is None:
                        t1.right = t2.right
                    else:
                        stack.append((t1.right, t2.right))
                        
                return root1
    ```

### 297. Serialize and Deserialize Binary Tree

- What
    - 질렬화, 역직렬화
- Why
    - 트리를 배열과 같이 직렬로 데이터를 처리하는 것
    - 배열을 트리로 전환하는 것
- How
    - BFS, DFS  
    
> BFS, 직렬화, 역질렬화
- solution
```python 
    class Codec:
    
        def serialize(self, root: TreeNode) -> str:
            queue = collections.deque([root])
            
            result = ['#']
            
            while queue:
                node = queue.popleft()
                if node:
                    queue.append(node.left)
                    queue.append(node.right)
                    
                    result.append(str(node.val))
                    
                else:
                    result.append('#')
            return ' '.join(result)
    
        def deserialize(self, data: str) -> TreeNode:
            if data == '# #':
                return None
            
            nodes = data.split()
            
            root = TreeNode(int(nodes[1]))
            queue = collections.deque([root])
            index = 2
            
            while queue:
                node = queue.popleft()
                if nodes[index] is not '#':
                    node.left = TreeNode(int(nodes[index]))
                    queue.append(node.left)
                index += 1
                if nodes[index] is not '#':
                    node.right = TreeNode(int(nodes[index]))
                    queue.append(node.right)
                index += 1    
            return root
```

### 110. Balanced Binary Tree
> dfs, 재귀

- solution
    - 양쪽 subtree의 높이를 +1하면서 차이를 계속 확인.
    1. 새로운 함수를 정의해서 리턴값을 비교하여 결과 산출
    2. left, right 깊이 들어가면서 비교
    3. left, right가 없으면 0 있으면 높이 + 1  
    ```python  
        class Solution:
            def isBalanced(self, root: TreeNode) -> bool:
                
                def check(root):
                    if not root:
                        return 0
                
                    left = check(root.left)
                    right = check(root.right)
        
                    if left == -1 or right == -1 or abs(left - right) > 1:
                        return -1
                    
                    return max(left, right) + 1
                
                return check(root) != -1
    ```

### 310. Minimum Height Trees
> BFS

- solution
    1. 그래프완성
    2. bfs로 길이가 1인 노드 자르기
    3. 2번 반복
    4. 최종적으로 2개 이하가 남으면 종료
    - 시간복잡도
        - 그래프 만들기 O(V)
        - 노드제거 O(V)
    - 공간복잡도
        - O(V)  
    ```python  
        class Solution:
            def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
                #예외처리, n = 1이하이면 return [0]
                if n <= 1:
                    return [0]
                
                #graph끼리 연결
                graph = collections.defaultdict(list)
                for i,j in edges:
                    graph[i].append(j)
                    graph[j].append(i)
                    
                #첫번재 리프노드 추가
                leaves = []
                for i in range(n + 1):
                    if len(graph[i]) == 1:
                        leaves.append(i)
                        
                #리프노드 제거하면서 최종노드 찾기
                #2개이상 님을 수도 있으므로 조건제시
                while n > 2:
                    n -= len(leaves)
                    new_leaves = []
                    for leaf in leaves:
                        neighbor = graph[leaf].pop()
                        graph[neighbor].remove(leaf)
                        #제거하고나서 연결노드가 1개인지 확인
                        if len(graph[neighbor]) == 1:
                            new_leaves.append(neighbor)
                    leaves = new_leaves
                return leaves
    ```
### 108. Convert Sorted Array to Binary Search Tree
> DFS, 재귀 

- solution
    1. 중앙에 위치한 값 슬라이싱
    2. 재귀적으로 중앙값 슬라이싱
    3. 값이 없으면 None 리턴, 있으면 node리턴  
    ```python  
        class Solution:
            def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
                if not nums:
                    return None
                
                mid = len(nums) // 2
                
                node = TreeNode(nums[mid])
                node.left = self.sortedArrayToBST(nums[:mid])
                node.right = self.sortedArrayToBST(nums[mid + 1:])
                
                return node
    ```
### 1038. Binary Search Tree to Greater Sum Tree
> 재귀, DFS

- solution
    1. BST는 정렬되어있음, 오른쪽이 가장 쿰
    2. 오른쪽에서 올라오면서 총합을 구함  
    ```python  
        class Solution:
            val: int = 0
            def bstToGst(self, root: TreeNode) -> TreeNode:
                if root:
                    self.bstToGst(root.right)
                    self.val += root.val
                    root.val = self.val
                    self.bstToGst(root.left)
                    
                return root
    ```
###

- 내풀이
```python  
class Solution:
    total: int = 0
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        if root:
            if low <= root.val <= high:
                self.total += root.val
            self.rangeSumBST(root.left, low, high)
            self.rangeSumBST(root.right, low, high)
        return self.total
```

> DFS, 가지치기

- solution 1  
```python 
class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        def dfs(node: TreeNode):
            if not node:
                return 0
            #가지치는 부분
            if node.val < low:
                return dfs(node.right)
            if node.val > high:
                return dfs(node.left)
            return node.val + dfs(node.left) + dfs(node.right)
        return dfs(root)
```

> 반복구조

- solution 2
```python 
class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        stack, sum = [root], 0
        
        while stack:
            node = stack.pop()
            if node:
                if node.val < high:
                    stack.append(node.right)
                if node.val > low:
                    stack.append(node.left)
                if low <= node.val <= high:
                    sum += node.val
        return sum
```

> 반복구조, BFS

- solution 3
```python 
class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        stack, sum = [root], 0
        
        while stack:
            node = stack.pop(0)
            if node:
                if node.val < high:
                    stack.append(node.right)
                if node.val > low:
                    stack.append(node.left)
                if low <= node.val <= high:
                    sum += node.val
        return sum
```

### 783. Minimum Distance Between BST Nodes
> DFS, 중위순회

- solution 1  
```python 
class Solution:
    def minDiffInBST(self, root: TreeNode) -> int:
        def dfs(node):
            if node:
                #왼쪽부터
                dfs(node.left)
                #가운데
                self.result = min(self.result, node.val - self.prev)
                self.prev = node.val
                #오른쪽
                dfs(node.right)
                               
        self.prev = -sys.maxsize
        self.result = sys.maxsize
        dfs(root)
        return self.result
```

> 반복순회, 중위순회

- solution 2
    ```python  
        class Solution:
            def minDiffInBST(self, root: TreeNode) -> int:
                #전, 결과 담아두기
                prev = -sys.maxsize
                result = sys.maxsize
                
                stack, node = [], root
                #왼쪽을 먼저 확인해야함 -> 차를 확인하기 때문, BST는 오름정렬
                #node와 stack이 모두 없을때 까지 진행
                #node는 left right가 없을경우가 있기때문
                #stack만 하지 않는 경우는 node 오른쪽 부분이 남아있을 수 있기 때문
                while stack or node:
                    while node:
                        stack.append(node)
                        node = node.left
                    
                    node = stack.pop()
                    result = min(result, node.val - prev)
                    prev = node.val
        
                    node = node.right
        
                return result
    ```



