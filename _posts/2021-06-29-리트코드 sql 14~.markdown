---
layout: post
title: '리트코드 sql 14~'
subtitle: '리트코드'
categories: sql
tags: practice
comments: True
---

> 리트코드 sql 문제풀이


-------------------------------------------------------------------------------

# 595. Big Countries

```sql
select name, population, area
from world
where area >= 3000000 or population >= 25000000
```

# 596. Classes More Than 5 Students

```sql
select class
from 
    ( select class, count(distinct student) as num
      from courses
      group by class
     ) temp_table
where num >= 5
```

# 601. Human Traffic of Stadium

- solution
```sql
with t as ( select t1.id , t1.visit_date , t1.people , 
            id - row_number() OVER(ORDER BY id) as grp
       from stadium t1
       where people >= 100 
          )
select t.id, t.visit_date ,t.people
from t 
where grp in ( select grp from t group by grp having count(*) >=3  )
```
- 진짜 기가막힌 방법이다...
    1. people이 100이하인거를 제거한 상태에서 id - rownumber를 빼주면 연속된 숫자이다면 차가 같다.
    2. 차가 같은것 끼리 묶어주고 3개이상인 것만 추출
    3. 해당한 id의 내용 출력 
    
```sql
select t1.*
from stadium t1, stadium t2, stadium t3
where t1.people >= 100 and t2.people >= 100 and t3.people >= 100
and
(
    (t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1)  -- t1, t2, t3
    or
    (t2.id - t1.id = 1 and t2.id - t3.id = 2 and t1.id - t3.id =1) -- t2, t1, t3
    or
    (t3.id - t2.id = 1 and t2.id - t1.id =1 and t3.id - t1.id = 2) -- t3, t2, t1
)
;
```

- id도 연속적인 것을 활용해 id차가 연속적인것들을 골라준다.
- 단 모든 경우의수를 찾지 않는 것은 셀프조인으로 시메트릭하기 때문 -> 2 1 3 = 2 3 1

# 620. Not Boring Movies

```sql
select *
from cinema
where id % 2 != 0 and description != 'boring'
order by rating desc
```
- id % 2 != 0 부분을 `mod(id,2) = 1` 로 작성할 수 있음

# 626. Exchange Seats

- solution 1
```sql
SELECT s1.id,
       Coalesce(s2.student, s1.student) AS student
FROM   seat s1
       INNER JOIN seat s2
               ON ( s1.id + 1 )^1 - 1 = s2.id 
```

- `(숫자+1)^1-1 자체가 비트연산을 통해 짝수 <-> 홀수를 바꿔주는 연산이 됨`, 두고두고 써먹기
- [비트연산](대기)

```sql
SELECT ( CASE
           WHEN MOD(id, 2) != 0
                AND counts != id THEN id + 1
           WHEN MOD(id, 2) != 0
                AND counts = id THEN id
           ELSE id - 1
         end ) AS id,
       student
FROM   seat,
       (SELECT Count(*) AS counts
        FROM   seat) AS seat_counts
ORDER  BY id ASC; 
```
- case when + 카티션 곱 활용

```sql
SELECT IF (id%2 <> 0, IF(id <> (SELECT Max(id)
                                FROM   seat), id + 1, id), id - 1) id,
       student
FROM   seat
ORDER  BY id; 
```
- if 문으로 풀이
- 이게 간단하고 활용성이 있는거 같다

# 627. Swap Salary

```sql
update salary
set
   sex = case sex
            when 'm' then 'f'
            else 'm'
         end;   
```
- update는 set과 같이 다닌다
- [update구문](대기)

```sql
update salary 
set sex = IF (sex = "m", "f", "m");
```

# 1179. Reformat Department Table

- 내풀이
```sql
select  id,
        max(case when month = 'Jan' then revenue end) 'Jan_Revenue',
        max(case when month = 'Feb' then revenue end) 'Feb_Revenue',
        max(case when month = 'Mar' then revenue end) 'Mar_Revenue',
        max(case when month = 'Apr' then revenue end) 'Apr_Revenue',
        max(case when month = 'May' then revenue end) 'May_Revenue',
        max(case when month = 'Jun' then revenue end) 'Jun_Revenue',
        max(case when month = 'Jul' then revenue end) 'Jul_Revenue',
        max(case when month = 'Aug' then revenue end) 'Aug_Revenue',
        max(case when month = 'Sep' then revenue end) 'Sep_Revenue',
        max(case when month = 'Oct' then revenue end) 'Oct_Revenue',
        max(case when month = 'Nov' then revenue end) 'Nov_Revenue',
        max(case when month = 'Dec' then revenue end) 'Dec_Revenue'
from 
        (select *, (row_number() over ( partition by month order by id)) rn
        from department
        ) rn_table
group by rn_table.id
```
- pivot table 만들기

# 1270. All People Report to the Given Manager

```sql
SELECT e1.employee_id
FROM   employees e1
       INNER JOIN employees e2
               ON e1.manager_id = e2.employee_id
       INNER JOIN employees e3
               ON e2.manager_id = e3.employee_id
WHERE  e3.manager_id = 1
       AND e1.employee_id != 1 
```
- 해당문제는 3개를 초과하지 않아서 조인을 2번사용하였는데 만약 개수제한이 없다면?


# 184. Department Highest Salary

- 내풀이
```sql
SELECT     d.name `department`,
           e.name   AS `employee`,
           e.salary AS salary
FROM       (
                    SELECT   *,
                             (Rank() over (partition BY departmentid ORDER BY salary DESC)) AS rk
                    FROM     employee) e
INNER JOIN department d
ON         e.departmentid = d.id
WHERE      e.rk = 1;
```

- solution
```sql
SELECT department.name AS 'Department',
       employee.name   AS 'Employee',
       salary
FROM   employee
       INNER JOIN department
         ON employee.departmentid = department.id
WHERE  ( employee.departmentid, salary ) IN (SELECT departmentid,
                                                    Max(salary)
                                             FROM   employee
                                             GROUP  BY departmentid); 
```

- solution은 굉장히 교과서 탄탄방법이다.

# 185. Department Top Three Salaries

- 내풀이 
```sql
SELECT     d.name 'Department',
           e_rk.name `employee`,
           e_rk.salary 'Salary'
FROM       (
                    SELECT   *,
                             (dense_rank() over (partition BY departmentid ORDER BY salary DESC)) rk
                    FROM     employee) e_rk
INNER JOIN department d
ON         e_rk.departmentid = d.id
WHERE      e_rk.rk <= 3;
```

- solution

```sql
SELECT d.name  AS 'Department',
       e1.name AS 'Employee',
       e1.salary
FROM   employee e1
       JOIN department d
         ON e1.departmentid = d.id
WHERE  3 > (SELECT Count(DISTINCT e2.salary)
            FROM   employee e2
            WHERE  e2.salary > e1.salary
                   AND e1.departmentid = e2.departmentid); 
```

- 순차적으로 조인을 시도하여 최종적으로 비교를 하면 됨
- 첫번째 방법보다는 편하지만 좋은 방법인지는 의문..

# 196. Delete Duplicate Emails
```sql
delete
from person
where id not in ( select * from (select min(id)
                                from person
                                group by email) as p);
```

- update, delete 등 from절에 쓰인 table을 바로 삭제할 수 없다
- 임시 테이블을 만들어서 삭제해야함
- [관련도큐먼트mysql](https://dev.mysql.com/doc/refman/5.6/en/update.html)

# 197. Rising Temperature

- 내풀이
```sql
select w2.id
from weather w1
        inner join weather w2
                on DATE_ADD(w1.recorddate, INTERVAL 1 day) = w2.recorddate
                   and w1.temperature < w2.temperature
```

- 날짜 더하기 date_add(더할날짜, interval 1 month, second, etc)
- 위 식을 아래와 같이 쓸 수 있다
- from 절에서 바로 조건식을 달 수 있음


- solution
```sql
SELECT weather.id AS 'Id'
FROM   weather
       INNER JOIN weather w
               ON Datediff(weather.recorddate, w.recorddate) = 1
                  AND weather.temperature > w.temperature

```

- 차이가 1나는 식으로도 조인이 가능하다. -> 사칙연산으로 조인가능 [해커랭크참고](https://www.hackerrank.com/challenges/the-report/problem)

# 197. Rising Temperature
```sql
SELECT t.request_at           AS 'Day',
       Round(1 - Avg(CASE
                       WHEN status = 'Completed' THEN 1
                       ELSE 0
                     end), 2) AS 'Cancellation Rate'
FROM   trips t
       INNER JOIN users u1
               ON t.client_id = u1.users_id
                  AND u1.banned != 'Yes'
       INNER JOIN users u2
               ON t.driver_id = u2.users_id
                  AND u2.banned != 'Yes'
GROUP  BY t.request_at 
```
- round ~ rate' 부분은 두고두고 곱씹어 먹어야할 구문이다.














