---
layout: post
title:  "(SQL)SQL 성능을 높이려면"
subtitle:   "요약정리"
categories: SQL
tags: theory
comments: true
---

> 단순 쿼리 작성공부가 아니라 깊은 이해를 위한 공부

> 해당내용을 모든 출처는 'SQL 레밸업'임

# 성능이 좋은 SQL이란?
앞의 DBMS 아키텍처에서 보았듯이 모든 SQL은 DBMS를 거쳐 실행계획을 기반으로 데이터를 추출한다. 이때 실행계획에는 대표적으로 아래의 3가지 사항이 있다.
  - 조작 대상 객체
  - 객체에 대한 조작의 종류
  - 조작 대상이 되는 레코드 수 : 카탈로그 정보에 기반한 수치

성능이 좋은 SQL이란 위 3가지 사항을 효율적으로 조작하는 것이다. 그렇다면 위의 3가지를 '잘' 조작하려면 어떻게 해야할까.
'SQL 레밸업'에서는 다음 2가지 방법을 제시한다.
  - 사고(집합 지향적인 사고, 집합 + 절차 지향적인 사고)
  - 결합(효율적인 결합)

그럼 위 2가지 방법에 대해서 알아보자.

# SQL에 적합한 사고는? 집합 or 절차
SQL에는 최초에 반복문이라는 것이 없었다. 반복이 없는게 좋다고 생각했기 때문이라고 한다.(159p)
흔히 많은 사람들이 반복적인 문제가 주어지면 다른 절차형 언어를 푸는 방식대로 SQL을 풀려고 한다. 
그래서 반복계의 늪에 빠진다. 반복계를 사용하면 성능에 치명적인 오류가 생긴다.

## 자르기, 부분집합을 만드는 방법 - 집합 지향적인 사고
GROUP BY와 PARTITION BY를 이용해 '자르기'기능을 활용하여 집합 지향적인 사고를 하자.
자르기는 '파티션(전체를 중복없이 나누는 부분집합)'으로 나눈다. 이러한 파티션들을 가지고 구문을 활용하여 SQL성능을 향상시키자. 

- 예시 문제 : 어린이, 성인, 노인으로 집계  

|name|age|  
|:---:|:---:|
|anderson|30|
|adela|21|
|bates|87|
|becky|54|
|bill|39|

```SQL
  SELECT  CASE WHEN age < 20 THEN '어린이'
               WHEN age BETWEEN 20 AND 69 THEN '성인'
               WHEN age >= 70 THEN '노인'
               ELSE NULL END AS age_class,
          COUNT(*)
  FROM    Persons
  GROUP   BY CASE WHEN age < 20 THEN '어린이'
                  WHEN age BETWEEN 20 AND 69 THEN '성인'
                  WHEN age >= 70 THEN '노인'
                  ELSE NULL END
```

## 반복계 - 절차 지향적 사고의 오류
### 반복계의 성능 오류  
1. 처리시간  
    - 처리시간은 '처리 횟수 * 한 회에 걸리는 처리시간'에 비례
    - 레코드가 많아지면 많아질수록 처리시간도 늘어남
2. SQL 실행의 오버헤드
    - SQL구문 파스, 실행 계획 생성 또는 평가에 오버헤드가 발생
    - SQL을 반복적으로 실행되기 때문
3. 병렬분산이 어려움
    - 반복계 SQL구문은 대부분 단순해서 1회의 SQL 구문이 접근하는 데이터양이 적음
    - I/O 병렬화하기 어려움
4. 데이터베이스 업그레이드 혜택을 받기 어려움
    - SQL구문이 단순하기 때문에 튜닝하기 어렵기 때문에 성능에 대한 혜택도 받기 어려움

### 반복계의 장점
아이러니하게도 반복계의 장점은 반복계의 장점에서 나온다.
1. 실행 계획의 안정성
  - SQL구문이 단순하기 때문에 실행계획이 변경되는 경우가 거의 없음
2. 예상 처리 시간의 정밀도
  - 처리 횟수 * 한 회에 걸리는 처리시간
3. 트랜잭션 제어가 편리
  - 오류가 발생한 지점부터 다시 진행할 수 있음
  
## SQL에서 반복을 표현하는 방법 - 집합 지항적인 사고
CASE식과 윈도우 함수를 사용하면 반복을 표현할 수 있다.
FROM, GROUP BY 등에서 윈도우 함수를 사용한다. 이 방법은 또한 스캔 횟수를 감소시켜 성능을 좋게한다.  
아래의 예시를 통해서 알아보자.  

- 문제 : 4130033과 가까운 우편번호 찾기

|pcode(우편번호)|district_name(지역이름)|  
|:---:|:---:|
|4130001|가|
|4130002|나|
|4130103|다|
|4130041|라|
|4103213|마|
|4380824|바|

```SQL
  SELECT  pcode,
          district_name
  FROM    (SELECT   pcode,
                    district_name,
                    CASE WHEN pcode = '4130033' THEN 0
                         WHEN pcode = '413003%' THEN 1
                         WHEN pcode = '41300%'  THEN 2
                         WHEN pcode = '4130%'   THEN 3
                         WHEN pcode = '413%'    THEN 4
                         WHEN pcode = '41%'     THEN 5
                         WHEN pcode = '4%'      THEN 6
                         ELSE NULL END AS hit_code,
                    MIN(CASE WHEN pcode = '4130033' THEN 0
                             WHEN pcode = '413003%' THEN 1
                             WHEN pcode = '41300%'  THEN 2
                             WHEN pcode = '4130%'   THEN 3
                             WHEN pcode = '413%'    THEN 4
                             WHEN pcode = '41%'     THEN 5
                             WHEN pcode = '4%'      THEN 6
                             ELSE NULL END)
                    OVER(ORDER BY CASE WHEN pcode = '4130033' THEN 0
                                       WHEN pcode = '413003%' THEN 1
                                       WHEN pcode = '41300%'  THEN 2
                                       WHEN pcode = '4130%'   THEN 3
                                       WHEN pcode = '413%'    THEN 4
                                       WHEN pcode = '41%'     THEN 5
                                       WHEN pcode = '4%'      THEN 6
                                       ELSE NULL END) AS min_code
          FROM PostalCode) Foo
  WHERE   hit_code = min_code
```
1. FROM 절에서 CASE식을 사용하여 스캔횟수를 1번사용하여 성능을 높임
2. 윈도우 함수를 사용해서 min을 추출하여 비교 가능하게 함  

# 지연의 주원인 결합 어떻게, 하면 성능을 높일것인가?

### 결합의 종류
결합은 기능적 관점으로 크게 3가지로 나눌 수 있다.  
- 크로스 결합 : 테이블간 결합키 없이 결합하여 생성할 수 있는 모든 경우의 수 
- 내부 결합 : 크로스 결합의 부분집합
- 외부 결합 : 크로스 결합에 없는 레코드도 생성하는 결합  
=> 내-외부라는 말은 크로스 결합의 부분집합인지 아닌지에 따라 지어짐

###  결합 알고리즘의 종류
1. Nested Loops
   - 작동방식
     - 구동테이블의 결합키를 기준으로 내부테이블을 하나씩 반복 스캔하면서 일치하면 리턴
   - 특징
     - 실행 시간은 레코드 수에 비례
     - 한 번의 단계에서 처리하는 레코드 수가 적어서 다른 알고리즘에 비해 메모리 소비가 적음
     - 모든 DBMS에서 지원
     - 결합 키 인덱스가 있으면 성능이 좋아짐 => 내부 테이블을 크게하여 인덱스 사용으로 반복 생략 효과를 크게함
2. Hash
   - 작동방식
     - 작은 테이블을 스캔 => 결합키를 해시값으로 변환 => 다른 테이블 결합키 스캔
   - 특징
     - 어느 한 테이블이 극단적으로 작지 않음
     - 해시 테이블을 만들어서 메모리를 크게 소모함
     - 출력되는 해시값은 입력값의 순서를 알지 못함으로 등치결합에만 사용 가능
   - 유용한 상황
     - 적절한 구동 테이블이 존재하지 안흔ㄴ 경우
     - 내부 테이블에서 히트되는 레코드 수가 너무 많은 경우
     - 내부 테이블에 인덱스가 존재하지 않는 경우
3. Sort Merge
   - 작동방식
     - 결합키로 정렬 => 일치하는 결합키끼리 결합
   - 특징
     - 테이블 정렬로 많은 메모리 소비
     - 등치, 부등호 결합 사용가능, 부정조건 사용 불가
   - 유용한 상황
     - 테이블 정렬을 스킵할 수 있는 경우

## 레코드 수 관점 알고리즘 선택
1. 소규모-소규모 : 모든 알고리즘 비등비등
2. 소규모-대규모 : Nested Loops 우선, 내부테이블에 결합할 레코드가 많다면 구동과 내부테이블을 바꾸거나, Hash사용
3. 대규모-대규모 : Hash 사용, 결합키로 정렬되어 있을 경우 Sort Merge

# 서브쿼리, 대체할 수 있는 수단이 있는가?

### 서브쿼리의 문제점  
서브쿼리는 장점이자 단점은 실체적인 데이터를 저장하지 않다는 점에서 발생한다.  
1. 연산 비용 추가
  - 서브쿼리에 접근할 때마다 SELECT구문 실행 => 실행비용 높아짐, 스캔발생
2. 데이터 I/O 비용 발생
  - 연산결과를 메모리에 저장해야하는데, 메모리 용량이 충분하지 않다면 오버헤드 발생
3. 최적화를 받을 수 없음
  - 옵티마이저가 쿼리를 해석하기 위해 필요한 정보를 서브쿼리에서는 얻을 수 없음

## 서브쿼리를 대체할 수 있는가?
일부 서브쿼리 결합을 아래의 윈도우 함수로 대체할 수 있다. 단, 윈도우 함수는 정렬비용이 추가된다. 하지만 윈도우 함수를 
사용하면 아래의 두 가지 이유로 좋다고 할 수 있다.  
1. 테이블 크기가 커진다고 했을때, 서브쿼리로 인한 결합비용보다 윈도우 함수 정렬비용이 적게 든다는 점 
2. 저장소 I/O를 줄이는 것이 SQL튜닝의 원칙이라는 점에서 윈도우 함수사용은 성능을 높인다고 할 수 있다.  

추가로, 윈도우 함수는 일반적으로 마지막 단계에서 SELECT문이 실행되므로, 
조작 대상 레코드 개수가 이미 압축된 상태여서 정렬에 필요한 메모리가 많이 필요하지 않음.

=> 서브쿼리를 사용하지 말자는 의미가 아니라 집합적인 사고로 불필요한 서브쿼리를 줄이는 SQL구문을 작성하자는 의미

## 서브쿼리가 유용한 때
서브쿼리는 반드시 존재한다. 하지만 결합 대상 레코드 수를 줄이는 서브쿼리는 완전 유용하다.  
앞서 살펴본 실행계획 3가지 요인을 생각해보면 유용한 상황을 유추할 수 있다.  
- 조작대상이 되는 레코드 수

위의 레코드 수를 서브쿼리를 통해 미리 줄이고 결합한다면 훨씬 성능이 좋은 SQL구문이 된다.

# SQL에 적합한 사고는? 집합 AND 절차
SQL스러운 집합 지향적인 사고가 떄로는 성능이 좋지 않을 때가 있다. 그럴때는 절차 지향적인 사고로 접근해보자.  

- 문제 예시 : 중앙값 구하기

|student_id|weight|
|:---:|:---:|
|A100|50|
|A101|55|
|A102|60|
|A103|65|
|A104|70|
|A105|75|
|A106|80|
|A107|85|

1. 집합 지향적인 코드
   - 비용 : w1, w2 결합, 스캔 발생  
```SQL
  SELECT  AVG(weight)
  FROM    (SELECT W1.weight
           FROM   weights w1, weights w2
           GROUP  BY w1.weight
           HAVING SUM(CASE WHEN w2.weight >= w1.weight THEN 1 ELSE 0 END)
                      >= COUNT(*) / 2
                  AND SUM(CASE WHEN w2.weight <= w1.weight THEN 1 ELSE 0 END)
                          >= COUNT(*) / 2) TMP
```

2. 절차 지향적인 코드
  - 윈도우 함수 사용  
```SQL
SELECT  AVG(weight)
FROM    (SELECT weight, 
                2 * ROW_NUMBER() OVER(ORDER BY weight)
                    - COUNT(*) OVER AS DIFF
         FROM   weights) TMP
WHERE   diff BETWEEN 0 AND 2
```


# SQL 레밸업의 핵심포인트

- 집합, 절차 상관없이 비용이 적은 SQL문으로 작성하자
- 비용은 결합, 스캔, 정렬등에서 발생한다.
    - 불필요한 서브쿼리, Union등은 CASE식, 윈도우 함수등으로 비용을 낮추는 방법으로 대체하자

















        
        



